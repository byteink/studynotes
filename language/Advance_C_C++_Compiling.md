[toc]
# 第2章 程序生命周期阶段基础
## 2.1 编译阶段
### 编译的各个阶段
1.  预处理阶段
2.  语言分析阶段
  - 词法分析：将源代码分割成不同的单词
   - 语法分析：将单词连接成单词序列，并验证其顺序是否合理
   - 语义分析：发现语句是否具有实际意义    
3.  汇编阶段
编译器将标准的语言集合转换成特定CPU指令集
4. 优化阶段
5. 代码生成阶段
汇编指令（可读的ASCII码）会在此阶段转换成对应机器指令的二进制，并写入目标文件的特定位置。
生成的二进制目标文件符合 ELF 格式规范。
### 目标文件属性
- 目标文件是通过其对应的源代码翻译得到的，编译的结果是一组目标文件。
- 符号（sysmbol）和节（section）是目标文件的基本组成部分。
  绝大多数的目标文件都包含代码节（.text）、初始化数据节（.data）、未初始化数据节（.bss）以及一些特殊节(如调试信息等）。
- 构建程序的目的在于将每个独立的源代码文件生成的节拼接到一个二进制可执行文件中。
- 目标文件中独立的节都有可能包含在最终的程序内存映射中，因此目标文件每个节的起始地址都设置为0,等待链接时调整。
   在链接阶段会确定程序内存映射中每个独立节的实际地址范围。
- 在将目标文件的节拼接到程序内部映射的过程中，其中唯一重要的参数是节的长度，准确地说是节的地址范围。
- 目标文件中的节都不会影响堆和栈中的数据，完全在运行时确定。
  除了需要指定堆和栈的默认长度外，并不需要程序指定任何其他初始化设置。
- 目标文件中只包含了程序.bss（未初始化数据)节的基本信息，而.bss节本身也仅仅只有字节长度信息。
  装载器会利用这些有限的数据为.bss节建立足够其数据存储的内存空间。
## 2.2 链接
链接的最终任务是将独立的节组合成最终的程序内存映射节，与此同时解析所有的引用。
### 链接阶段
1.  重定位   
仅仅进行拼接，将分散在单独目标文件中不同类型的节拼接到程序内存映射节中。
需要将之前预留的空间，也就是从0开始的地址空间范围转换成最终程序内存映射中更具体的地址范围。
2.  解析引用
引发链接问题的根本原因：
> 代码片段在不同的编译单元，它们之间尝试相互引用，但在将目标文件拼接成程序内存映射之前，又无从知晓引用对象的内存地址。
这部分代码会引发问题往往是因为引用了其他的程序内存（函数入口点）或者数据内存（全局数据、静态数据、外部数据）中的地址。

   为了解决这类问题，需要在链接阶段就对这些引用进行解析，此时链接器需要：
    - 检查拼接到程序内存映射中的节
    - 找出哪些部分代码产生了外部引用
    - 计算该引用的精确地址（在内存映射中的地址）
    - 最后将机器指令中的伪地址替换成在程序内存映射的实际地址，就样就完成了引用的解析。
## 2.3 可执行文件属性
链接过程的最终结果是二进制可执行文件。为了解析各个编译单元直接的引用，确保不同部分之间的函数调用与变量访问准确有效，
生成代码节（.text）时，需要链接器对其进行修改。

可执行文件并不完全是通过编译项目源代码文件生成的。用于启动程序的一部分非常重要的代码片段，是在链接阶段才添加到程序内存映射中的。
链接器通常将这部分代码存放在程序内存映射的起始处。启动代码有两种不同形式：
- crt0 是”纯粹“的入口点，这是程序代码的第一部分，在内核控制下执行；
- crt1 是更为现代化的启动例程（startuproutine），可以在 main 函数执行前与程序终止后完成一些任务。

# 第3章 加载程序执行阶段
## 3.1 shell的重要性
shell通过复制自身的进程内存映射来创建新进程的内存映射，在这个过程中将自身的环境变量传递给新进程。
## 3.2 内核的作用
shell一旦委托了运行程序的任务，内核将通过调用exec函数族中的函数来作出响应。
下一步操作（fs/exec.c:search_binary_handler）是识别可执行格式。
如果识别了ELF格式，下一步将调用load_elf_binary函数（位于 fs/binfmt_elf.c）中，之后为程序准备进程内存映射。
## 3.3 装载器的作用
### 装载器视角下的二进制文件（节与段）
装载器的功能比链接器简单很多。它最重要的功能就是将链接器所创建的节复制到进程内存映射中。
装载器并不需要了解各个节的内部结构，就能完成复制。
它只关系节是否只读或可读写属性，以及在可执行文件启动前是否需要打补丁。

装载器还会根据节的相同装载需求将链接器创建的节组合成段（segment）。
### 程序加载阶段
- 首先装载器会定位可执行二进制文件中的 PT_INTERP 段，用于动态加载阶段。
- 接着装载器会读取程序的二进制文件段的头，确定每个段的地址和字节长度。
   在这个阶段装载器仍然不会向程序的内存映射中写入任何数据。
  装载器在此阶段会建立并维护一组包含可执行文件段（实际上就是每个段的页宽）和程序内存映射关联的结构（比如 vm_are_struct)
- 真正从可执行文件复制段的操作是在程序启动之后才执行的。
   在执行复制的时候，分配给进程的物理内存页和程序内存映射表之间的虚拟内存映射关系已经建立好了。
   只有当内核在运行时需要某个程序段时才会开始加载其对应的页，这种策略使得程序每一部分只有在运行时真正需要时才加载。
## 3.4 程序执行入口点
###装载器查找入口点
在程序装载完成后（即准备程序基本数据和复制执行程序必要的节到内存中），装载器会查询到ELF头的 e_entry 字段的值。
这个值包含的程序内存地址指定了程序该从何处开始运行，通常就是 _start 函数的首地址。
### _start()函数的作用
_start 函数的作用是为接下来需要调用的 __libc_start_main 函数准备入参。该函数定义如下：
```cpp
int __libc_start_main(int (*main) (int, char**, char**),       /* address of main function */
                   int argc,                                   /* number of comand line args */
                   char *__unbounded *__unbounded ubp_av,      /* command line args array */
                   void (*init) (void),                        /* address of init function */
                   void (*fini) (void),                        /* address of fini function */
                   void (*rtld_fini) (void),                   /* address of dynamic linker fini function */
                   void (*__unbounded stack_end));             /* end of stack address */
```
### __libc_start_main()函数的作用
该函数为程序启动准备环境的过程中扮演了重要的角色。
在程序启动阶段，它不仅仅为程序准备好运行环境，还会执行以下操作：
- 启动程序的线程
- 调用 _init()函数，该函数会在调用 main() 函数前完成必要的初始化操作。
  gcc 编译器利用 `__attribute__((constructor))`关键字对程序启动前的自定义操作提供支持。
- 注册 _fini() 和 rtld_fini() 函数，这些函数会在程序终止时调用。
   通常来说， _fini() 和 _init() 函数操作时的顺序相反。
   gcc利用`__attribute((destructor))`关键字对程序结束时的自定义操作提供支持。
- 最后，当所有准备操作都完成时， __libc_start_main() 调用 main() 函数，启动程序。

# 第4章 重用概念的作用
## 4.1 静态库
静态库只是目标文件的归档文件。
## 4.2 动态库
在动态库的所有部分中，只有与其他进程共享代码节（.text节）才是有意义的，而共享数据则没有意义。
### 动态库和共享库
利用位置无关代码（position independent code，PIC），通过修改动态库代码访问符号的方式，只需加载一次动态库，通过内存映射实现共享。
由于PIC概念的出现，动态库也被设计成共享库，后面也不在区分动态库和共享库。
虚拟内存的概念为PIC的实现奠定了基础。
### 动态链接详解
动态链接过程中执行的操作：
1. 构建动态库
构建动态库生成的二进制文件本质上是与可执行文件相同的，唯一区别在于动态库缺少了让其独立执行的启动例程（startup routines）。
2. 依靠信任来构建客户端可执行文件（只查找文件）
构建依赖动态库的可执行文件时：
链接器只关心动态库的符号，只会检查二进制文件中所需要的符号能否都在动态库中找到。
不关心动态库任何节的细节，也不会对动态库的二进制接口进行检查，不会查找节或节的大小，也不会将节拼接到最终的二进制文件中。
3. 运行时装载和符号解析
- 可执行文件找到动态库文件的位置
- 进程将动态库载入内存映射中。运行时动态库的函数符号必须与构建阶段的完整函数签名相同 （从属关系（affiliations）、函数名、参数列表和链接与调用惯例）相同，但不要求两者的汇编代码相同。
- 运行时将可执行程序的符号解析到正确的地址上。这个地址是动态库所映射到的进程内存映射的地址。
### 动态库的特点
- 创建动态库需要完整的构建过程。不仅需要编译阶段，还需要链接阶段才能完成。
- 动态库还可以链接其他库。
### 应用程序二进制接口（ABI）
可以把ABI当作编译链接阶段中根据源代码接口创建的符号集合。
## 4.3 静态库和动态库对比
### 导入选择条件的差异
1. 链接静态库时不会把整个静态库的内容链接进来，只会链接目标文件中必要的符号。（粒度局限于单个目标文件）。
2. 链接动态库时，客户端二进制文件的字节长度只有记录新符号信息的少量开销。
3. 导入静态库所有object文件：`-Wl,--whole-archive`

# 第5章 使用静态库
## 5.1 创建静态库
使用`ar`工具将目标文件打包进一个归档文件中。
`ar`工作还可以从库文件中删除、替换、提取一个或多个目标文件。
## 5.3 静态库设计技巧
### 丢失符号可见性和唯一性的可能性
客户二进制链接静态库后，静态库中的符号成为客户二进制文件符号列表的一部分，并保留其原有可见性。
但客户二进制是一个动态库时这个规则会被打破。
### 将静态库转换为动态库
- 使用`ar`工具
```sh
ar -x <static library>.a
```
会把目标文件提取出来。
- 链接器使用提取出来的目标文件集合构建动态库。
### 静态库在64位Linux平台上的问题
静态库链接到共享库则要求静态库需要用`-fPIC`编译器选项来构建。
# 第6章 设计动态链接库：基础篇
## 6.1 创建动态链接库
构建动态链接库的过程至少需要下面两个选项：
- `-fPIC`编译器选项
- `-shared`链接器选项

在32位体系结构下，不需要使用`-fPIC`编译器选项，但如果没有指定，编译出来的动态库就会遵循旧式的装载时重定位机制，
也就是说只有第一次加载该动态库的进程才能将其映射到自身进程内存映射中。
在64位体系结构下，不制定`-fPIC`选项将会导致链接错误。
## 6.2 设计动态库
### 设计二进制接口
C++的问题：
- 问题1：使用了更加复杂的符号命名规则
为了唯一标识相同签名的函数，产生了“名称修饰”这种技术。（Name mangling）
名称修饰是将函数名、函数的从属信息（类或作用域）、函数的参数列表进行组合，最后生成符号名称的过程。
问题的根源在于，名称修饰惯例没有一个统一的标准，是由编译器自己规定的。
在C++编译器中，即使使用C风格函数默认也会为其创建带修饰的名称。可以使用`extern "C"`关键字来避免
```cpp
#ifdef __cpluscplus
extern "C"
{
#endif  // __cplusplus
int myfunc(int x, int y);
#ifdef __cpulsplus
}
#enif
```
- 问题2：静态初始化顺序问题
多个目标文件中的非局部静态对象的初始化顺序不定。
- 问题3：模板
### 设计应用程序的二进制接口
- 规则1：用一组C风格的函数来实现动态库ABI
- 规则2：提供完整ABI声明的头文件
不仅仅提供函数原型，还要提供预处理器定义，结构体布局等信息
- 规则3：使用被广泛支持的标准 C 关键字
- 规则4：使用类工厂机制（C++）或模块（C）
使用类静态成员函数返回接口指针
- 规则5：只对外提供必要的符号
内部使用的函数不允许客户可执行文件直接访问，好处有
  - 增强对私有内容的保护
  - 通过减少对外提供符号的数量可以大大提高库的加载顺序
  - 减少同名冲突
- 规则6：利用命名空间来解决符号名称冲突问题
### 控制动态库符号的可见性
- 在构建过程中控制符号的可见性
  1. 影响所有代码：`-fvisibility`编译选项
  2. 影响单个符号：`__attribute__((visibility("<default | hidden>"))`
  3. 影响单个或一组符号：`#pragma GCC visibility [push | pop]`
- 向链接器传递脚本 `-Wl,--version-script`
- 使用`strip`工具删除符号
#### 完成链接需要满足的条件


## 6.3 动态链接模式

